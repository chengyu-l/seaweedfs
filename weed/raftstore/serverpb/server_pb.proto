syntax = "proto3";

package serverpb;

option go_package = "serverpb";

message KeyValue {
  // key is the key in bytes. An empty key is not allowed.
  bytes key = 1;
  // value is the value held by the key, in bytes.
  bytes value = 5;
}

message Metadata {
  uint64 NodeID    = 1;
  uint64 ClusterID = 2;
}

message ResponseHeader {
  // cluster_id is the ID of the cluster which sent the response.
  uint64 cluster_id = 1;
  // member_id is the ID of the member which sent the response.
  uint64 member_id = 2;
  // raft_term is the raft term when the request was applied.
  uint64 raft_term = 3;
}

message RangeRequest {
  enum SortOrder {
    NONE = 0; // default, no sorting
    ASCEND = 1; // lowest target value first
    DESCEND = 2; // highest target value first
    }
  enum SortTarget {
    KEY = 0;
    VALUE = 1;
    }
  // key is the first key for the range. If range_end is not given, the request only looks up key.
  bytes key = 1;
  // range_end is the upper bound on the requested range [key, range_end).
  // If range_end is '\0', the range is all keys >= key.
  // If range_end is key plus one (e.g., "aa"+1 == "ab", "a\xff"+1 == "b"),
  // then the range request gets all keys prefixed with key.
  // If both key and range_end are '\0', then the range request returns all keys.
  bytes range_end = 2;
  // limit is a limit on the number of keys returned for the request. When limit is set to 0,
  // it is treated as no limit.
  int64 limit = 3;
  // sort_order is the order for returned sorted results.
  SortOrder sort_order = 4;
  // sort_target is the key-value field to use for sorting.
  SortTarget sort_target = 5;
  // serializable sets the range request to use serializable member-local reads.
  // Range requests are linearizable by default; linearizable requests have higher
  // latency and lower throughput than serializable requests but reflect the current
  // consensus of the cluster. For better performance, in exchange for possible stale reads,
  // a serializable range request is served locally without needing to reach consensus
  // with other nodes in the cluster.
  bool serializable = 6;
  // keys_only when set returns only the keys and not the values.
  bool keys_only = 7;
  // count_only when set returns only the count of the keys in the range.
  bool count_only = 8;
}

message RangeResponse {
  ResponseHeader header = 1;
  // kvs is the list of key-value pairs matched by the range request.
  // kvs is empty when count is requested.
  repeated KeyValue kvs = 2;
  // more indicates if there are more keys to return in the requested range.
  bool more = 3;
  // count is set to the number of keys within the range when requested.
  int64 count = 4;
}

message PutRequest {
  // key is the key, in bytes, to put into the key-value store.
  bytes key = 1;
  // value is the value, in bytes, to associate with the key in the key-value store.
  bytes value = 2;
}
message PutResponse {
  ResponseHeader header = 1;
}

message DeleteRangeRequest {
  // key is the first key to delete in the range.
  bytes key = 1;
  // range_end is the key following the last key to delete for the range [key, range_end).
  // If range_end is not given, the range is defined to contain only the key argument.
  // If range_end is one bit larger than the given key, then the range is all the keys
  // with the prefix (the given key).
  // If range_end is '\0', the range is all keys greater than or equal to the key argument.
  bytes range_end = 2;
}

message DeleteRangeResponse {
  ResponseHeader header = 1;
  // deleted is the number of keys deleted by the delete range request.
  int64 deleted = 2;
}

message RequestOp {
  // request is a union of request types accepted by a transaction.
  oneof request {
      RangeRequest request_range = 1;
      PutRequest request_put = 2;
      DeleteRangeRequest request_delete_range = 3;
      TxnRequest request_txn = 4;
    }
}

message ResponseOp {
  // response is a union of response types returned by a transaction.
  oneof response {
      RangeResponse response_range = 1;
      PutResponse response_put = 2;
      DeleteRangeResponse response_delete_range = 3;
      TxnResponse response_txn = 4;
    }
}

message Compare {
  enum CompareResult {
      EQUAL = 0;
      GREATER = 1;
      LESS = 2;
      NOT_EQUAL = 3;
      EXIST = 4;
      NOT_EXIST = 5;
  }
  enum CompareTarget {
      VALUE = 0;
      KEY = 1;
    }
  // result is logical comparison operation for this comparison.
  CompareResult result = 1;
  // target is the key-value field to inspect for the comparison.
  CompareTarget target = 2;
  // key is the subject key for the comparison operation.
  bytes key = 3;
  oneof target_union {
      bytes value = 4;
    }
  // range_end compares the given target to all keys in the range [key, range_end).
  // See RangeRequest for more details on key ranges.
  bytes range_end = 100;
}

// From google paxosdb paper:
// Our implementation hinges around a powerful primitive which we call MultiOp. All other database
// operations except for iteration are implemented as a single call to MultiOp. A MultiOp is applied atomically
// and consists of three components:
// 1. A list of tests called guard. Each test in guard checks a single entry in the database. It may check
// for the absence or presence of a value, or compare with a given value. Two different tests in the guard
// may apply to the same or different entries in the database. All tests in the guard are applied and
// MultiOp returns the results. If all tests are true, MultiOp executes t op (see item 2 below), otherwise
// it executes f op (see item 3 below).
// 2. A list of database operations called t op. Each operation in the list is either an insert, delete, or
// lookup operation, and applies to a single database entry. Two different operations in the list may apply
// to the same or different entries in the database. These operations are executed
// if guard evaluates to
// true.
// 3. A list of database operations called f op. Like t op, but executed if guard evaluates to false.
message TxnRequest {
  // compare is a list of predicates representing a conjunction of terms.
  // If the comparisons succeed, then the success requests will be processed in order,
  // and the response will contain their respective responses in order.
  // If the comparisons fail, then the failure requests will be processed in order,
  // and the response will contain their respective responses in order.
  repeated Compare compare = 1;
  // success is a list of requests which will be applied when compare evaluates to true.
  repeated RequestOp success = 2;
  // failure is a list of requests which will be applied when compare evaluates to false.
  repeated RequestOp failure = 3;
}

message TxnResponse {
  ResponseHeader header = 1;
  // succeeded is set to true if the compare evaluated to true or false otherwise.
  bool succeeded = 2;
  // responses is a list of responses corresponding to the results from applying
  // success if succeeded is true or failure if succeeded is false.
  repeated ResponseOp responses = 3;
}

message SnapshotRequest {
}

message SnapshotResponse {
  // header has the current key-value store information. The first header in the snapshot
  // stream indicates the point in time of the snapshot.
  ResponseHeader header = 1;
  // remaining_bytes is the number of blob bytes to be sent after this message
  uint64 remaining_bytes = 2;
  // blob contains the next chunk of the snapshot in the snapshot stream.
  bytes blob = 3;
}

message Member {
  // ID is the member ID for this member.
  uint64 ID = 1;
  // name is the human-readable name of the member. If the member is not started, the name will be an empty string.
  string name = 2;
  // peerURLs is the list of URLs the member exposes to the cluster for communication.
  repeated string peerURLs = 3;
  // clientURLs is the list of URLs the member exposes to clients for communication. If the member is not started, clientURLs will be empty.
  repeated string clientURLs = 4;
  // isLearner indicates if the member is raft learner.
  bool isLearner = 5;
}

message MemberAddRequest {
  // peerURLs is the list of URLs the added member will use to communicate with the cluster.
  repeated string peerURLs = 1;
  // isLearner indicates if the added member is raft learner.
  bool isLearner = 2;
}

message MemberAddResponse {
  ResponseHeader header = 1;
  // member is the member information for the added member.
  Member member = 2;
  // members is a list of all members after adding the new member.
  repeated Member members = 3;
}

message MemberRemoveRequest {
  // ID is the member ID of the member to remove.
  uint64 ID = 1;
}

message MemberRemoveResponse {
  ResponseHeader header = 1;
  // members is a list of all members after removing the member.
  repeated Member members = 2;
}

message MemberRaftAttrUpdateRequest {
  // ID is the member ID of the member to update.
  uint64 ID = 1;
  // peerURLs is the new list of URLs the member will use to communicate with the cluster.
  repeated string peerURLs = 2;
}

message MemberRaftAttrUpdateResponse{
  ResponseHeader header = 1;
  // members is a list of all members after updating the member.
  repeated Member members = 2;
}

// Attributes represents all the non-raft related attributes of an member.
message Attributes {
  string name = 1;
  repeated string client_urls = 2;
}

message MemberNoRaftAttrUpdateRequest {
  uint64 member_id = 1;
  Attributes member_attributes = 2;
}

message MemberNoRaftAttrUpdateResponse {
}

message MemberPromoteRequest {
  // ID is the member ID of the member to promote.
  uint64 ID = 1;
}

message MemberPromoteResponse {
  ResponseHeader header = 1;
  // members is a list of all members after promoting the member.
  repeated Member members = 2;
}

message MoveLeaderRequest {
  // targetID is the node ID for the new leader.
  uint64 targetID = 1;
}

message MoveLeaderResponse {
  ResponseHeader header = 1;
}


message MemberListRequest {
}

message MemberListResponse {
  ResponseHeader header = 1;
  // members is a list of all members associated with the cluster.
  repeated Member members = 2;
}

message StatusRequest {
}

message StatusResponse {
  ResponseHeader header = 1;
  // leader is the member ID which the responding member believes is the current leader.
  uint64 leader = 2;
  // isLearner indicates if the member is raft learner.
  bool isLearner = 3;
  // raftIndex is the current raft committed index of the responding member.
  uint64 raftIndex = 4;
  // raftTerm is the current raft term of the responding member.
  uint64 raftTerm = 5;
  // raftAppliedIndex is the current raft applied index of the responding member.
  uint64 raftAppliedIndex = 6;
  // dbSize is the size of the backend database physically allocated, in bytes, of the responding member.
  int64 dbSize = 7;
  // dbSizeInUse is the size of the backend database logically in use, in bytes, of the responding member.
  int64 dbSizeInUse = 8;
  repeated string errors = 9;
}

message DefragmentRequest {
}

message DefragmentResponse {
  ResponseHeader header = 1;
}

